<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyOrbit Pro Camera</title>
</head>
<body style="background: #000; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; font-family: sans-serif;">

    <h2>MyOrbit Camera</h2>

    <div style="width: 90%; max-width: 400px; border: 2px solid #333; border-radius: 15px; overflow: hidden;">
        <video id="video-feed" autoplay playsinline style="width: 100%; height: auto; display: block;"></video>
    </div>

    <div style="margin-top: 20px; display: flex; gap: 10px;">
        <button id="btn-start" style="padding: 10px 20px; background: green; color: white; border: none; border-radius: 5px;">ON</button>
        <button id="btn-flip" style="padding: 10px 20px; background: blue; color: white; border: none; border-radius: 5px;">FLIP</button>
        <button id="btn-snap" style="padding: 10px 20px; background: orange; color: white; border: none; border-radius: 5px;">PHOTO</button>
    </div>

</body>
</html>
const video = document.getElementById('video-feed');
const btnStart = document.getElementById('btn-start');

let stream = null;
let currentFacingMode = "user"; 

async function startCamera(mode) {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
    }

    try {
        stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: mode },
            audio: false
        });

        video.srcObject = stream;
    } catch (err) {
        console.log("Error: Camera access denied");
    }
}

btnStart.addEventListener('click', () => {
    startCamera(currentFacingMode);
});
const btnFlip = document.getElementById('btn-flip');

async function flipCamera() {
    currentFacingMode = (currentFacingMode === "user") ? "environment" : "user";
    await startCamera(currentFacingMode);
}

btnFlip.addEventListener('click', flipCamera);
const btnSnap = document.getElementById('btn-snap');

function takePhoto() {
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    const context = canvas.getContext('2d');
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    const imageData = canvas.toDataURL('image/png');
    
    const link = document.createElement('a');
    link.href = imageData;
    link.download = 'MyOrbit_Capture.png';
    link.click();
}

btnSnap.addEventListener('click', takePhoto);
let mediaRecorder;
let recordedChunks = [];

async function startRecording() {
    recordedChunks = [];
    mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'video/webm;codecs=vp9'
    });

    mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
            recordedChunks.push(event.data);
        }
    };

    mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'MyOrbit_Video.webm';
        a.click();
    };

    mediaRecorder.start();
}

function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
    }
}
<button id="btn-record" style="padding: 10px 20px; background: red; color: white; border: none; border-radius: 5px;">REC</button>
<button id="btn-stop" style="padding: 10px 20px; background: black; color: white; border: none; border-radius: 5px;">STOP</button>
<select id="filter-select" style="padding: 10px; border-radius: 5px; background: #333; color: white;">
    <option value="none">Normal</option>
    <option value="grayscale(100%)">B&W</option>
    <option value="sepia(100%)">Vintage</option>
    <option value="invert(100%)">Negative</option>
    <option value="brightness(150%)">Bright</option>
</select>
<div style="margin-top: 15px; color: white;">
    <label>Zoom: </label>
    <input type="range" id="zoom-slider" min="1" max="3" step="0.1" value="1">
</div>
const zoomSlider = document.getElementById('zoom-slider');

zoomSlider.addEventListener('input', () => {
    video.style.transform = `scale(${zoomSlider.value})`;
    video.style.transformOrigin = "center";
});
<select id="res-select" style="padding: 10px; border-radius: 5px; background: #333; color: white;">
    <option value="vga">Normal (VGA)</option>
    <option value="hd">High Definition (HD)</option>
</select>
const resSelect = document.getElementById('res-select');

resSelect.addEventListener('change', () => {
    const quality = resSelect.value;
    let constraints = { facingMode: currentFacingMode };

    if (quality === "hd") {
        constraints.width = { ideal: 1280 };
        constraints.height = { ideal: 720 };
    } else {
        constraints.width = { ideal: 640 };
        constraints.height = { ideal: 480 };
    }

    startCameraWithConstraints(constraints);
});

async function startCameraWithConstraints(videoConstraints) {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
    }

    try {
        stream = await navigator.mediaDevices.getUserMedia({
            video: videoConstraints,
            audio: true
        });
        video.srcObject = stream;
    } catch (err) {
        console.log("Error: Resolution not supported");
    }
}
<button id="btn-torch" style="padding: 10px 20px; background: #f1c40f; color: black; border: none; border-radius: 5px;">TORCH ON/OFF</button>
const btnTorch = document.getElementById('btn-torch');
let torchEnabled = false;

async function toggleTorch() {
    if (!stream) return;
    
    const track = stream.getVideoTracks()[0];
    const capabilities = track.getCapabilities();

    if (capabilities.torch) {
        torchEnabled = !torchEnabled;
        try {
            await track.applyConstraints({
                advanced: [{ torch: torchEnabled }]
            });
        } catch (err) {
            console.log("Torch error: ", err);
        }
    } else {
        console.log("Torch not supported on this device/camera");
    }
}

btnTorch.addEventListener('click', toggleTorch);
const video = document.getElementById('video-feed');
const btnStart = document.getElementById('btn-start');
const btnFlip = document.getElementById('btn-flip');
const filterSelect = document.getElementById('filter-select');

let stream = null;
let currentFacingMode = "user";

async function startCamera(mode) {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
    }

    const constraints = {
        video: { facingMode: mode },
        audio: false
    };

    try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
    } catch (err) {
        console.log("Camera access error: " + err.name);
    }
}

function autoCapture() {
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const context = canvas.getContext('2d');

    context.filter = filterSelect.value;
    context.drawImage(video, 0, 0, canvas.width, canvas.height);

    const imageData = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.href = imageData;
    link.download = `MyOrbit_${Date.now()}.png`;
    link.click();
}

btnStart.addEventListener('click', () => startCamera(currentFacingMode));

btnFlip.addEventListener('click', async () => {
    currentFacingMode = (currentFacingMode === "user") ? "environment" : "user";
    await startCamera(currentFacingMode);
});

filterSelect.addEventListener('change', () => {
    video.style.filter = filterSelect.value;
    setTimeout(autoCapture, 500);
});
video.addEventListener('click', async (event) => {
    if (!stream) return;
    const track = stream.getVideoTracks()[0];
    const capabilities = track.getCapabilities();

    if (capabilities.focusMode && capabilities.focusMode.includes('manual')) {
        await track.applyConstraints({
            advanced: [{ focusMode: 'manual', pointsOfInterest: [{x: event.clientX, y: event.clientY}] }]
        });
    }
});
<button id="btn-timer" style="padding: 10px 20px; background: #e67e22; color: white; border: none; border-radius: 5px;">TIMER (3s)</button>

<div id="timer-display" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 80px; color: white; font-weight: bold; pointer-events: none;"></div>
const btnTimer = document.getElementById('btn-timer');
const timerDisplay = document.getElementById('timer-display');

function startCountdown(seconds) {
    let timeLeft = seconds;
    timerDisplay.innerText = timeLeft;

    const interval = setInterval(() => {
        timeLeft--;
        
        if (timeLeft > 0) {
            timerDisplay.innerText = timeLeft;
        } else {
            clearInterval(interval);
            timerDisplay.innerText = "";
            autoCapture(); // Photo click karne wala function (Step 13)
        }
    }, 1000);
}

btnTimer.addEventListener('click', () => {
    startCountdown(3); // 3 seconds ka timer
});
<div style="position: relative; display: inline-block;">
    <video id="video-feed" autoplay playsinline style="width: 100%; max-width: 500px; background: black;"></video>
    
    <div id="grid-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none;">
        <div style="position: absolute; top: 33.3%; width: 100%; height: 1px; background: rgba(255,255,255,0.5);"></div>
        <div style="position: absolute; top: 66.6%; width: 100%; height: 1px; background: rgba(255,255,255,0.5);"></div>
        <div style="position: absolute; left: 33.3%; height: 100%; width: 1px; background: rgba(255,255,255,0.5);"></div>
        <div style="position: absolute; left: 66.6%; height: 100%; width: 1px; background: rgba(255,255,255,0.5);"></div>
    </div>
</div>

<button id="btn-grid" style="margin-top: 10px; padding: 10px;">GRID ON/OFF</button>
const btnGrid = document.getElementById('btn-grid');
const gridContainer = document.getElementById('grid-container');

btnGrid.addEventListener('click', () => {
    const isHidden = gridContainer.style.display === "none";
    gridContainer.style.display = isHidden ? "block" : "none";
});
<button id="btn-burst" style="padding: 10px 20px; background: #2ecc71; color: white; border: none; border-radius: 5px;">BURST (5x)</button>
const btnBurst = document.getElementById('btn-burst');

async function triggerBurst(count) {
    for (let i = 0; i < count; i++) {
        takeSnap(); // Using the takeSnap function from Step 18
        // Wait for 300ms between each shot to avoid browser lag
        await new Promise(resolve => setTimeout(resolve, 300));
    }
}

btnBurst.addEventListener('click', () => {
    triggerBurst(5); // Takes 5 photos rapidly
});

// Final takeSnap function ensuring no reference errors
function takeSnap() {
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');

    // Sync filters from the video element to the canvas
    ctx.filter = getComputedStyle(video).filter;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    const data = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = data;
    a.download = `MyOrbit_Burst_${Date.now()}.png`;
    a.click();
}
<div id="gallery-preview" style="position: absolute; bottom: 20px; right: 20px; width: 60px; height: 60px; border: 2px solid white; border-radius: 8px; overflow: hidden; background: #000; display: none; cursor: pointer;">
    <img id="preview-img" style="width: 100%; height: 100%; object-fit: cover;">
</div>
const galleryPreview = document.getElementById('gallery-preview');
const previewImg = document.getElementById('preview-img');

function takeSnap() {
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');

    ctx.filter = getComputedStyle(video).filter;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    const data = canvas.toDataURL('image/png');

    // 1. Update Preview Thumbnail
    previewImg.src = data;
    galleryPreview.style.display = "block";

    // 2. Automated Download
    const a = document.createElement('a');
    a.href = data;
    a.download = `MyOrbit_${Date.now()}.png`;
    a.click();
}

// 3. Open full image when thumbnail is clicked
galleryPreview.addEventListener('click', () => {
    window.open(previewImg.src, '_blank');
});
